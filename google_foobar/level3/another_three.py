# the structure that is generated by the mach and facula numbers is a binary tree where the children take on the sum of 
# the current mach and facula numbers in their respective position. using a depth first search algorithm solves the problem, however this 
# approach does not scale well with large inputs. here a bottom up approach is used where we start with the solution and see if we
# can get back to the original number of mach and facula bombs that could be sneaked onto the ship, i.e. (1, 1). If we can get
# back to (1, 1), a counter variable reports the number of generations required, otherwise it is impossible. The main problem to consider is then
# that we may be on a left or a right node on the tree. Fortunately, since we effectively sum the mach and the facula numbers for the next
# generation we know with certainty that if the mach number is greater than the facula number we are on a left node and vice versa.
# 
# consider the basic tree
# (1, 1) 
# {(2, 1)};   {(1, 2)}        
# {(3, 1), (2, 3)};   {(3, 2), (1, 3)}
# {(4, 1), (3, 4); (5, 3), (2, 5)}; {(5, 2), (3, 5); (4, 3), (1, 4)} 
#
#
# say e.g. we are looking for (2, 5)
# we know it must be on a right node since 5 > 2, hence the right value must change (a left node constitutes changing the left value)...
# (2, 5) -> (2, 3) -> (2, 1) -> (1, 1) done, return 3
# 
# now say e.g. we are looking for (2, 4):
# (2, 4) -> (2, 2) done, cannot be valid
#
# if we arrive at equal mach and facula numbers we terminate early. the solution is accepted if and only if we can get to (1, 1)
# the algorithm this approach produces is O(N) since it moves up one node at a time (for one input fixed). This can be beaten if we traverse diagonals 
# within the tree, so e.g.  
# (2, 5) -> (2, 1) -> (1, 1) done 
# 

def solution(x, y):
    # edge case when (x, y) == ("1", "1")
    if (x, y) == ("1", "1"):
        return "0"

    counter = 0
    x = int(x)
    y = int(y)
    while x >= 1 and y >= 1 and x != y:
        # if eiter x or y equals 1 then we know we can get to (1,1) in y-1 or x-1 steps respectively
        if x == 1:
            counter += y - 1
            return str(counter)
        elif y == 1:
            counter += x - 1
            return str(counter)
        # if we are on a left node we traverse up and right until we cannot anymore and vice versa  
        if x > y:
            # this means we are on a left node
            diag_length = x//y
            counter += diag_length
            x = x - y*diag_length
        elif y > x:
            # this means we are on a right node
            diag_length = y//x
            counter += diag_length
            y = y - x*diag_length

        
    return "impossible"


import time


print(solution('2', '5')) # 3
print(solution('2', '4')) # impossible 
print(solution('3', '2')) # 2
print(solution('4', '7')) # 4
print(solution('2', '1')) # 1
print(solution('1', '6')) # 5
print(solution('1', '1')) # 0
print(solution('3', '4')) # 3 
now = time.time()
print(solution('1', '1000')) # 999
print(f"Time: {time.time() - now}")

now = time.time()
print(solution('1', '10000')) # 9999
print(f"Time: {time.time() - now}")

now = time.time()
print(solution('1', '100000')) # 99999
print(f"Time: {time.time() - now}")

now = time.time()
print(solution('1', '10000000000000')) # 9999999999999
print(f"Time: {time.time() - now}")

now = time.time()
print(solution('100000000', '1')) # 9999999
print(f"Time: {time.time() - now}")

now = time.time()
print(solution('1234', '5555555555')) # 4502105, +/- 1.2s
print(f"Time: {time.time() - now}")

now = time.time()
print(solution('1234', '55555555555')) # 45020735, +/- 12s
print(f"Time: {time.time() - now}")

now = time.time()
print(solution('1234', '5555555555555555')) # 45020735, +/- 12s
print(f"Time: {time.time() - now}")

now = time.time()
print(solution('9123456123585', '546879846513216587654654678321321564654846')) # 45020735, +/- 12s
print(f"Time: {time.time() - now}")